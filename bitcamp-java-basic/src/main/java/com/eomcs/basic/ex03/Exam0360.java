package com.eomcs.basic.ex03;

//# 부동소수점의 리터럴 - 2진수로 변경된 것을 확인하기
//- 자바가 부동소수점을 다룰 때 IEEE 754 규칙에 따라 2진수로 변환하는 것을 확인해 보자.

public class Exam0360 {
  public static void main(String[] args) {
    System.out.println(2.127f);
    System.out.println(-2.127);
    System.out.println(2.127);
    System.out.println(-2.127f);
  }
}    

//## 실습
//1) 컴파일하기
//- $ javac -d bin/main -encoding UTF-8 src/main/java/com/ohoracs/basic/ex03/Exam35.java
//
//2) 클래스 파일로 부동소수점 값 확인하기
//- Exam35.class 파일을 hexdump 플러그인으로 출력한다.
//- 12.375의 2진수 값인 0100_0001_0100_0110_0000_0000_0000_0000을 찾아본다.
//  보통 에디터에서는 2진수를 16진수로 바꿔 보여주기 때문에 16진수 값 0x41460000을 찾아보라!


//방법 소수점 이상 부분을 2진수로 변환 12-> 1100(2진수)
// 소수점 이하 부분을 2진수로 변환  0.375->  0.78
//1100+0.011을 합침 =1100.011
//
//
// ### 실수 값을 정규화하는 방법 = 실수 값을 32비트 2진수로 만드는 방법
// - 예: 12.375(10진수)
//
// 1) 소수점 앞의 정수 값을 2진수로 변환한다.
//   12(10진수)
//   = 1100(2진수)  
// 
// 2) 소수점 뒤의 값을 2진수로 변환한다.
// - 변환 규칙
// - 소수점을 2로 곱하여 나온 결과에서 정수 부분만을 차례대로 표기한다.
// - 소수 부분이 0이거나 반복되면 계산을 멈춘다.
// - 예: 0.375(10진수)
//   0.375 * 2 = 0.75  --> 0
//   0.75 * 2  = 1.5   --> 1
//   0.5 * 2   = 1.0   --> 1
//   => 0.011(2진수)
//3)소수점 이상 2진수와 소수점 이하 2진수를 더함
//4)정규화
//소수점 위치를 조정하여 가수부와 지수부를 분리한다
//소수점 왼쪽에 1만 남도록 소수점 위치를 이동한다.
// 1.100011 * 2**3
//소수점 앞의 1은 무조건 1이기 때문에 버린다
//100011 *2**3
//가수부 지수부로 나눈다 분리한다
//가수부는 = 100011 (Sign-Magnitude로 표현한다.) 따라서 음수나 양수나 같은 2진수 값을 가진다 
//예) 100011
//지수부 2의 제곱승 값이다. Excess-K로 표현한다.
//K값은 127이다 
//예) 3(2의제곱승) +127(값:bios) =130 이진수로 표현
// 1000 0010
//32 비트 메모리에 담기
// [1비트:부호비트][8비트:지수부][나머지 가수부] 
//0_1000_0010_100011000000000000000000000000....
//0100_0001_0100_0110_0000_0000_0000_0000
//41_46_00_00
//64비트 메모리에 담기
//[1비트:부호비트][11비트:지수부][나머지 52가수부] 
//0_0001000_/0010_1000/11000000/00000000/000000000000000000000
//0000_1000?0010_1000_1100_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000
//08_28_C0_00_00_00_00